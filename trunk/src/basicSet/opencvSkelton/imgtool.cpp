// 
// opencvSkelton
// imgtool.cpp
// 
// The MIT License
// 
// Copyright (c) 2009 sonson, sonson@Picture&Software
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//#include "imgtool.h"#define DEFAULT_WINDOWNAME "OpenCV"void showRGBPixelsInWindow( unsigned char*pixel, int width, int height ) {	IplImage *img = NULL;	char *wndName = DEFAULT_WINDOWNAME;	img = cvCreateImage( cvSize( width, height ), 8, 3 );		char *windowPixel = img->imageData;	for ( int x = 0; x < img->width; x++ )		for ( int y = 0; y < img->height; y++ ) {			*( windowPixel + img->widthStep * y + 3 * x + 2 ) = *( pixel + 3 * ( img->width * y + x )     );			*( windowPixel + img->widthStep * y + 3 * x + 1 ) = *( pixel + 3 * ( img->width * y + x ) + 1 );			*( windowPixel + img->widthStep * y + 3 * x     ) = *( pixel + 3 * ( img->width * y + x ) + 2 );		}		cvNamedWindow( wndName, CV_WINDOW_AUTOSIZE );	cvShowImage( wndName, img );	cvResizeWindow( wndName, width, height );		cvWaitKey(0);		cvReleaseImage( &img );	cvDestroyWindow( wndName );}void showGrayPixelsInWindow( unsigned char*pixel, int width, int height ) {	IplImage *img = NULL;	char *wndName = DEFAULT_WINDOWNAME;	img = cvCreateImage( cvSize( width, height ), 8, 1 );		char *windowPixel = img->imageData;	for ( int x = 0; x < img->width; x++ )		for ( int y = 0; y < img->height; y++ ) {			*( windowPixel + img->widthStep * y + x ) = *( pixel + img->width * y + x );		}		cvNamedWindow( wndName, CV_WINDOW_AUTOSIZE );	cvShowImage( wndName, img );	cvResizeWindow( wndName, width, height );		cvWaitKey(0);		cvReleaseImage( &img );	cvDestroyWindow( wndName );}#ifdef __RE_ALIGNE_PIXELS//// 画像を上下逆さまにする関数//unsigned char* inverseImage(unsigned char*data,int width, int height, int n_pixels, int colors) {	unsigned char *reAlignedData;	reAlignedData = (unsigned char *)malloc( n_pixels * colors * sizeof(unsigned char) );	int x,y,color_count;	int inv_x,inv_y;	for ( x = 0; x < width; x++ ) {		inv_x = x;		for ( y = 0; y < height; y++ ) {			inv_y = height - 1 - y;			for ( color_count = 0; color_count < colors; color_count++ )				*( reAlignedData + colors * ( x + y * width ) +color_count ) = *( data + 3 * ( inv_x + inv_y * width ) + color_count );		}	}	return reAlignedData;}#endif/* * たいていの画像を読み込んでしまう関数 */unsigned char * magick_read(const char * filename, int * width, int *height, const char * colormap){	ExceptionInfo exception;	Image * image;	ImageInfo * image_info;	unsigned char * data;	int n_pixels;	int colors;		GetExceptionInfo(&exception);	image_info=CloneImageInfo((ImageInfo *)NULL);		strncpy(image_info->filename, filename, MaxTextExtent-1);	image=ReadImage(image_info, &exception);		if (image == (Image *)NULL){		MagickWarning(exception.severity,exception.reason,exception.description);		return NULL;	}	*width	= image->columns;	*height = image->rows;	colors	= strlen(colormap);	n_pixels = image->columns * image->rows;	data = (unsigned char *)malloc( n_pixels * (colors) * sizeof(unsigned char));		if( ! DispatchImage(image, 0, 0, *width, *height, colormap, CharPixel, (void *)(data), &exception) ){		MagickWarning(exception.severity,exception.reason,exception.description);		return NULL;	}		DestroyImage(image);	DestroyImageInfo(image_info);#ifdef __RE_ALIGNE_PIXELS	unsigned char*alignedData =  inverseImage(data,*width, *height, n_pixels, colors);	free(data);	return alignedData;#endif	return data;}/* * たいていの画像形式で書き込んでしまう関数 */int magick_write(const char * filename, unsigned char * data, int width, int height, const char * colormap){	Image * image;	ExceptionInfo exception;	ImageInfo * image_info;	CompressionType comp;	int quality;		comp = UndefinedCompression; /* ほかには LZWCompression など */	quality = 0;#ifdef __RE_ALIGNE_PIXELS	int colors	= strlen(colormap);	int n_pixels= width*height*colors;	unsigned char*alignedData = inverseImage(data, width, height, n_pixels, colors);	data = alignedData;#endif		GetExceptionInfo(&exception);	image_info=CloneImageInfo((ImageInfo *)NULL);	image = ConstituteImage( width, height, colormap, CharPixel, (const void*)data, &exception );#ifdef __RE_ALIGNE_PIXELS	free(alignedData);#endif	if (image == (Image *)NULL){		MagickWarning(exception.severity,exception.reason,exception.description);		return 1;	}		strncpy(image->filename, filename, MaxTextExtent-1);		if( quality > 0 && quality <= 100 ){		image_info->quality = quality;	}	image->compression = comp;	image_info->compression = comp;	/*	 * char で渡すので， 8 bits per color とする (デフォルトは16っぽい)．	 * 	 * if( ( (image_info->compression == NoCompression) || (image->depth > 8) ) \) が，	 * PNM で ASCII フォーマットになる条件らしい．	 *	 * see imagemagick/coders/pnm.c	 */	image->depth = 8;		if( 0 == WriteImage(image_info, image) ){		MagickWarning(image->exception.severity,image->exception.reason,exception.description);		return 1;	}	DestroyImage(image);	DestroyImageInfo(image_info);		return 0;}